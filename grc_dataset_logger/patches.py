#
# This file is part of the GNU Radio LLM project.
#

import functools
import inspect

from importlib.util import spec_from_file_location, module_from_spec
from pathlib import Path
from typing import Any, Tuple, Type

from grc_dataset_logger.flowgraph_logger import FlowgraphLogger
from grc_dataset_logger.action_logger import ActionLogger

from gnuradio.gr.top_block import top_block


GRC_FLOWGRAPH_METHODS = (
    'get_run_command',
    'new_block',
    'remove_element',
    'connect',
    'disconnect',
)


def load_top_block(path: Path) -> Tuple[Any, Type[top_block]]:
    spec = spec_from_file_location('flowgraph_module', str(path))
    if spec is None or spec.loader is None:
        raise ImportError(f'Could not load flowgraph module from {path}')
    module = module_from_spec(spec)
    spec.loader.exec_module(module)

    # Try to find main()
    main_func = getattr(module, 'main', None)
    if main_func is None or not callable(main_func):
        raise ValueError('No main function found in flowgraph script')

    # Check the default arguments generated by GRC
    signature = inspect.signature(main_func)
    top_block_cls = None
    if 'top_block_cls' in signature.parameters:
        default = signature.parameters['top_block_cls'].default
        if inspect.isclass(default) and issubclass(default, top_block):
            top_block_cls = default

    if top_block_cls is None:
        raise ValueError('Could not infer top_block class from main signature')

    return (main_func, top_block_cls)


def hook_method(cls, method, hook):
    original = getattr(cls, method)

    @functools.wraps(original)
    def wrapped(self, *args, **kwargs):
        result = original(self, *args, **kwargs)
        try:
            override = hook(self, method, args, kwargs, result)
            return override if override is not None else result
        except Exception as e:
            return result
    setattr(cls, method, wrapped)


def patch_flowgraph(logger: FlowgraphLogger):
    """
    This function patches selected methods in GRC's flowgraph model.
    """
    from gnuradio.grc.core.FlowGraph import FlowGraph

    def on_flowgraph_change(self, method, args, kwargs, result):
        if method == 'get_run_command':
            if isinstance(result, str):
                script_path = result.split(' ')[-1]
                wrapped = (f'python -c "from grc_dataset_logger.launch_top_block '
                           f'import execute_script; execute_script(\'{script_path}\')"')
                return wrapped
        logger.on_flowgraph_change(self, method, args, kwargs)
        return None

    for method in GRC_FLOWGRAPH_METHODS:
        if hasattr(FlowGraph, method):
            hook_method(FlowGraph, method, on_flowgraph_change)
    print('---> GRC dataset logger hooked GRC successfully')


def patch_top_block(tb_cls: Type[top_block], logger: ActionLogger):
    def on_top_block_change(self, method, args, kwargs, result):
        print(f'Top block method "{method}" called with args: {args}, kwargs: {kwargs}, result: {result}', flush=True)
        logger.on_top_block_change(self, method, args, kwargs)
        return None

    for name in dir(tb_cls):
        if name.startswith('set_') or name.startswith('get_'):
            original = getattr(tb_cls, name, None)
            if callable(original):
                hook_method(tb_cls, name, on_top_block_change)
